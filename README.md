# 심화 프로그래밍 2024
IoT 개발자 심화 프로그래밍 언어 학습 리포지토리

## 1일차
- 개발환경 설치
	- Visual Studio 2022 Community 설치
	- C, C++ 소스코드 실행
	- C++ 개념
	
- 제어문
	1. 선택제어문 
		- if, switch
		- if, else 문(C언어종류) / elif = Python
		- 반복문 For
		- 반복문 While
		- Overloading(재정의), Overriding
		
	2. 반복제어문 
		- for,while
		- for(초기식; 조건식; 증감식){
			1. 초기식을 가지고 조건식을 따진다.
			2. 참이면 for문의 실행문 실행
			3. 증감식을 실행
			4. 조건식을 따지고
			2.
			3.
			4.
			.
			.
			.
		}
	
- 지역변수 = 로컬변수
	1. 선언되어진 범위 안에서만 사용이 가능(static 영역에 저장)

- 자료형
	1. 문자 : 문자(char),문자열
	2. 숫자 : 정수(int),실수
	
- 계산기 만들기

## 2일차
- C에서 메모리
	- 실행중인 프로그램은 운영체제로부터 메모리 공간을 할당 받는데, 크게 데이터, 스택, 힙 영역으로 나뉜다.
		1. 데이터 : 전역변수가 저장되는 영역, 함수, 전역변수, 상수, 문자리터럴
		2. 스택 : 지역변수 및 매개변수가 저장되는 영역
		3. 힙(heap) : 사용자에게 할당된 영역, malloc 함수호출에 의해 프로그램이 실행되는 과정에서 동적으로 할당이 이뤄지는 영역
		- malloc & free : malloc 함수호출에 의해 할당된 메모리 공간은 free 함수호출을 통해서 소멸하지 않으면 해제되지 않는다.
		- 사용하려면 malloc()(C++:new)으로 할당받고 free()(C++:delete)로 반환

- A & B => 비트연산자 : A와 B를 논리곱 연산해라
	- 0b1000 1111(2진수)	: 0x8f(16진수) // 8421
	- 0b 1011 0010 = 0xb2

- A & B 연산하기
	- A : 0b 1000 1111
	- B : 0b 1011 0010
	- A&B :  1000 0010
	
- A && B => 논리연산자 : 논리곱(A, B 둘 다 참이면 참)

- 참조자
```cpp
int num = 10;		// 일반적인 변수 선언
int* ptr = &num1;	// 포인터 변수 ptr에 num1의 주소값 저장
int& num2 = num1;	// num1에 대한 참조자 num2를 선언
// 이미 선언된 변수 앞에 &가 오면, 주소 값의 반환을 뜻하지만
// 새로 선언되는 변수의 이름 앞에 &가 오면, 참조자의 선언을 뜻함

// 참조자 선언과 동시에 변수로 초기화! 그래야 별명을 지어주지
int* pnum = &num;	// 주소로 num변수에 접근 => 변수의 주소 값 저장 
int &rnum = num;	// 참조로 num변수에 접근 => 참조자 rnum 선언, num의 메모리공간에 rnum이라는 이름이 하나 더 생긴 것! 
```

## 3일차 => 조퇴해서 정리 필요!! (p126-136)
- 객체지향 언어의 꽃은 클래스!
	- new라는 키워드로 객체 생성
	- 그럼 우리가 만드는 객체는 힙 영역에 만들어지겠지
	- 힙 영역에 객체 생성, 스택 영역에서 포인터 변수를 만들기!
	- 힙 영역에 만들어져 있는 메모리 주소를 스택 영역에 있는 포인터 변수에 넣어서 접근한다!

## 4일차
- Class
	- 멤버 변수와 멤버 함수로 구성된다.
	- 클래스 내부에는 멤버들의 선언으로 작성된다.
	- 멤버 함수의 정의를 외부로 빼낸다. (스코프 연산자 사용)
	- 일반적으로 멤버 변수는 private, 멤버함수 public을 사용한다.
	
- 생성자(Constructor)
	- 클래스 이름과 같은 멤버 함수로 출력은 없다.
	- 객체 생성 시 자동으로 호출되는 멤버 함수
	- 모든 클래스는 디폴트 생성자를 가지고 있다.
	- 만약 명시적으로 생성자를 작성하면 디폴트 생성자의 호출은 불가하며 디폴트 생성자가 필요한 경우는 명시적으로 작성한다.
	- 멤버 변수들의 초기화를 담당한다.

- 멤버 이니셜라이저(Member Initializer)
	- 객체 생성 전에 선언과 동시에 초기화가 필요한 경우에 사용한다.
	- const 변수와 참조 변수의 초기화에 사용한다.
	- 이니셜라이저를 사용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다.
	- const 변수, 참조자 : 선언과 동시에 초기화해야함

## 5일차 => 조퇴 (복사 생성자 전체)
- 메모리 공간의 할당 이후에 생성자의 호출까지 완료되어야 '객체'라고 할 수 있다.
- 즉, 객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야 한다.
- 생성자를 정의하지 않는 클래스에는 C++ 컴파일러에 의해 디폴트 생성자라는 것이 자동으로 삽입된다.
- 따라서 모든 객체는 한번의 생성자 호출을 동반한다.
- new 연산자를 이용한 객체의 생성 시에도 생성자가 호출된다.
	- AAA *ptr = new AAA;
- 단, C언어의 malloc 함수 사용 시 생성자는 호출되지 않는다!!!
	- AAA *ptr = (AAA*)malloc(sizeof(AAA));
	- malloc 함수 호출 시 실제로는 AAA 클래스의 크기 정보만 바이트 단위로 전달되므로, 생성자가 호출될 리 없다.
=> 객체를 동적으로 할당하려는 경우에는 반드시 new 연산자를 사용해야한다!	

- this 포인터
	- 멤버함수 내에서는 this라는 이름의 포인터 사용 가능
	- 객체 자신을 가리키는 용도로 사용되는 포인터
	- this는 객체자신의 주소 값을 의미함
	- this 포인터는 그 주소값과 자료형이 정해져 있지 않은 포인터
	
포인터 배열 : 포인터를 저장하는 배열
배열 포인터 : 배열을 가리키는 포인터, 배열의 주소를 저장하고 있는 포인터

## 6일차
- 복사 생성자가 무한히 반복 가능하기 때문에
- 복사 생성자는 입력으로 객체를 받는, 참조 타입으로 받는 생성자
- 생성자의 오버로딩!
- 복사 생성자의 매개변수 선언에 const는 필수가 아님, 그치만 참조형의 선언을 의미하는 &는 반드시 삽입!!
- & 선언이 없다면 복사 생성자의 호출은 무한루프에 빠짐 

- 복사 생성자의 호출 시점
	1. 기존에 생성된 객체를 이용해 새로운 객체를 초기화하는 경우
	2. Call-by-value 방식의 함수 호출 과정에서 객체를 인자로 전달하는 경우
	3. 객체를 반환하되, 참조형으로 반환하지 않는 경우

```cpp
int func(int a) {	// a = 10;, num의 10을 복사해서 사용한다.
	a = 10 + a;
	return a;		// a = 20;
}
// main에서
int num = 10;
int res = func(num);	// res = 20; , a의 20과 res의 20은 다른 놈! a 반환 후 a가 없어지기전에 a의 값을 '복사'해서 사용하는거!! => 복사 생성자 호출됨
```

## 7일차
*  UnivStudent의 생성자는 Person의 생성자를 호출하는 형태로 Person 클래스의 멤버를 초기화하는 것이 좋다!
```cpp
//UnivStudent 클래스의 생성자
UnivStudent(char* myname, int myage, char* mymajor) : Person(myage, myname)
{
	strcpy(major, mymajor);
}
/*
UnivStudent의 멤버 뿐만 아니라 Person의 멤버를 초기화 하기 위한 인자 전달!
이니셜라이저 => 생성자의 호출을 의미함
즉, Person 클래스의 생성자를 호출하면서 인자로 myage와 myname에 저장된 값을 전달하는 것
UnivStudent 클래스와 같이, 상속받는 클래스는 이니셜라이저를 이용해서 상속하는 클래스의 생성자 호출을 명시할 수 있다.
*/
```

- 유도 클래스의 객체가 소멸될 때에는, 유도 클래스의 소멸자가 실행되고 난 다음에 기초 클래스의 소멸자가 실행된다.
- 기초 클래스의 소멸자도, 유도 클래스의 소멸자도 호출됨을 기억하자
- 생성자에서 동적 할당한 메모리 공간은 소멸자에서 해제해야한다!

## 8일차
- 오버로딩(Overloading) - 다중정의
- 오버라이딩(Overriding) - 재정의, 상속 관계에서 사용

- C++ 컴파일러는 포인터를 이용한 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로 판단함!
- 실제 가리키는 객체의 자료형을 기준으로 판단하지 않음!!!!!!!
- 접근은 객체 포인터의 타입을 따름!!

```cpp
/*
부모 타입의 객체 포인터로 자식 객체를 가리킬 수 있다!
하지만 자식 타입의 객체 포인터로 부모 객체는 가리킬 수 없다.
그리고 접근은 객체 포인터의 타입을 따른다!!!!!! 그래서 ptr1->Sleep(); 했을 때 Student 클래스의 Sleep()이 아니라 Person 클래스의 Sleep()
*/
Person* ptr1 = new Student();			// Student는 Person을 상속, Person형 포인터 변수는 Student 객체를 가리킬 수 있음
Person* ptr2 = new PartTimeStudent();	// PartTimeStudent는 Person을 간접 상속!, Person형 포인터 변수는 PartTimeStudent 객체를 가리킬 수 있음
Student* ptr3 = new PartTimeStudent();	// PartTimeStudent는 Student를 상속, Student형 포인터 변수는 PartTimeStudent 객체를 가리킬 수 있음
```

```cpp
int main(void)
{
	// Derived 클래스는 Base 클래스를 상속받음
	Derived* dptr = new Derived();
	Base* bptr = dptr;
}
// dptr은 Derived 클래스의 포인터 변수! 그럼 이 포인터가 가리키는 객체는 분명 Base 클래스를 직접 혹은 간접적으로 상속하는 객체!
// 따라서 Base형 포인터 변수로도 참조가 가능하다! 라고 컴파일러가 판단함

```

- 가상함수(Virtual Function)
	- virtual 키워드의 선언을 통해 가상함수의 선언이 이뤄진다.
	- 가상함수가 선언되고 나면, 이 함수를 오버라이딩 하는 함수도 가상함수가 된다.
	- 함수가 가상함수로 선언되면, 해당 함수 호출 시 포인터의 자료형을 기반으로 호출대상을 결정하지 않고,
	- 포인터 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다!!

- 순수 가상함수(Pure Virtual Function)
	- 함수의 몸체가 정의되지 않은 함수
	```cpp
	virtual int GetPay() const = 0;
	virtual void ShowSalaryInfo() const = 0;
	```
	- 0의 대입을 의미하는 게 아니라, 명시적으로 몸체를 정의하지 않았음을 컴파일러에게 알리는 것.
	
- 추상 클래스(Abstract Class)
	- 하나 이상의 멤버 함수를 순수 가상함수로 선언한 클래스
	- 객체 생성이 불가능한 클래스
	
* C++의 객체와 멤버함수는 다음과 같은 관계를 가진다.
	- 객체가 생성되면 멤버 변수는 객체 내에 존재하지만,
	- 멤버함수는 메모리의 한 공간에 별도로 위치하고선, 이 함수가 정의된 클래스의 모든 객체가 이를 공유하는 형태를 취한다!!

## 9일차
- 복사 생성자 호출
	- 새로 생성하는 객체 pos2의 초기화에 기존에 생성된 객체 pos1 사용!
	```cpp
	int main(void)
	{
		Point pos1(5, 7);
		Point pos2 = pos1;
	}
	```
- 대입 연산자 호출
	- pos1, pos2 모두 이미 생성 및 초기화가 진행된 객체
	- 기존에 생성된 두 객체간의 대입 연산 시 대입 연산자 호출됨
	```cpp
	int main(void)
	{
		Point pos1(5, 7);
		Point pos2(9, 10);
		pos2 = pos1;
	}
	```

## 10일차 (p470~489 진도 따라잡기)
- new 연산자
	1. 메모리 공간의 할당 
	2. 생성자의 호출
	3. 할당하고자 하는 자료형에 맞게 반환된 주소 값의 형 변환
	=> C언어의 malloc()과는 달리, new 연산자가 반환하는 주소 값을 형 변환할 필요가 없다.
	
	- 우리는 메모리 공간의 할당만 오버로딩 할 수 있다!
	- 반환형은 반드시 void 포인터 형, 매개변수형은 size_t
	=> void* operator new(size_t size) {...}
- delete 연산자의 오버로딩
	=> void operator delete(void* adr) { delete[] adr; }
	- 사용하는 컴파일러에서 void 포인터 형 대상의 delete 연산을 허용하지 않는다면
	- char형 포인터 형으로 변환해서 delete 연산 진행하면 됨 => delete[] ((char*)adr);
	
-디폴트 대입 연산자 (문제점 해결)
   - 상속 구조에서의 대입 연산자 호출 
   - 배열요소에 접근할 때 사용하는 [] 연산자 오버로딩 
   
-배열의 인덱스 연산자 오버로딩
   -const 함수를 이용한 오버로딩의 활용 
   -객체 저장을 위한 배열 클래스의 정의 
   
-연산자 오버로딩 
   -new연산자 오버로딩에 대한 상세한 이해 
   -delete 연산자 오버로딩에 대한 상세한 이해
   -포인터 연산자 오버로딩
   -연산자의 오버로딩과 펑터 
	
- Person p = p1;	// 복사
- p = p1;			// 대입

## 11일차
- 함수 템플릿
	- 함수를 만드는 도구
	- 함수 템플릿이 만들어 내는 함수의 자료형은 결정되어 있지 않다.
	- 따라서 다양한 자료형의 함수를 만들어낼 수 있다!
	```cpp
	template <typename T>	// T라는 이름을 이용하여 아래의 함수를 템플릿으로 정의하겠다.
	// template <class T> 도 사용 가능!, T 말고 다른 문자도 사용 가능!
	T Add(T num1, T num2)
	{
		return num1 + num2;
	}
	```
- 함수 템플릿 - 함수를 만드는데 사용되는 템플릿
- 템플릿 함수 - 템플릿을 기반으로 만들어진 함수